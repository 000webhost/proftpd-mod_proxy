
mod_proxy's own NetIO API

Why?  So that mod_proxy can properly open NetIO streams for e.g. proxied
TLS connections, where the frontend (or backend) connections might not have
TLS enabled.  This is not a use case for which the core NetIO API, as currently
implemented, is suited.

To work around this, while the core NetIO API is redesigned, mod_proxy has
its own version.  Will this even work, given how the core NetIO API might
be called transitively, e.g. via pr_data_xfer?

The key difference in the Proxy NetIO API is that the underlying NetIO object
to use is explicitly specified, rather than being assumed.

  pr_netio_stream_t *proxy_netio_open(pool *, int strm_type, int mode,
    pr_netio_t *netio);

  int proxy_netio_read(pr_netio_stream_t *nstrm, pr_netio_t *netio,
    char *buf, size_t bufsz, int len);

  int proxy_netio_write(pr_netio_stream_t *nstrm, pr_netio_t *netio,
    char *buf, size_t bufsz);

  int proxy_netio_close(pr_netio_stream_t *, pr_netio_t *netio);

  int proxy_netio_poll(pr_netio_stream_t *nstrm, pr_netio_t *netio);

  int proxy_netio_postopen(pr_netio_stream *nstrm, pr_netio_t *netio);

  int proxy_netio_printf(pr_netio_stream_t *nstrm, pr_netio_t *netio,
    const char *fmt, ...);

  void proxy_netio_set_poll_interval(pr_netio_stream_t *nstrm,
    pr_netio_t *netio, unsigned int interval);

mod_proxy currently calls the core NetIO API in these places:

  lib/proxy/conn.c:
    pr_netio_open (CONVERTED)
    pr_netio_poll (CONVERTED)
    pr_netio_close (CONVERTED)
    pr_netio_printf (CONVERTED)

  lib/proxy/ftp/ctrl.c:
    pr_netio_read (CONVERTED)
    pr_netio_printf (CONVERTED)

  lib/proxy/ftp/data.c:
    pr_netio_read (CONVERTED)
    pr_netio_write (CONVERTED)

  mod_proxy.c:
    pr_netio_postopen (CONVERTED)
    pr_netio_set_poll_interval (CONVERTED)

NOTE: We will ALSO need to wrap the pr_response_* API, as that is another
place where the core (not proxy) NetIO API will be used, albeit indirectly.
OR maybe we DO not need to this; the pr_response_* API is used for the
frontend connections, which will use the normal mod_tls NetIO.  Right?

Initial implementation:

  Proxy NetIO API simply delegates to core NetIO API.

ALTERNATIVELY, the Proxy NetIO API doesn't have to re-implement its own
things.  Consider something like this:

  int proxy_netio_read(pr_netio_stream_t *nstrm, pr_netio_t *netio,
    char *buf, size_t bufsz, int len);

    /* Get currently registered NetIO (maybe TLS?) */
    curr_netio = pr_get_netio(strm_type);
    /* curr_netio->owner (module *), curr_netio->owner_name */

    /* Unregister the current NetIO */
    pr_unregister_netio(strm_type);

    /* Register the netio we WANT for the duration of this operation */
    pr_register_netio(proxy_netio, strm_type);

    /* XXX do operation */

    /* Unregister our NetIO */
    pr_unregister_netio(strm_type);

    /* Re-register the old NetIO */
    pr_register_netio(curr_netio, strm_type);

This assumes the overhead for NetIO registration isn't large (it will happen
A LOT for mod_proxy!). Also, for:

  client -- (ftp) --> proxy -- (ftps) --> server

how is mod_proxy to get its hands on the mod_tls NetIO, without mod_tls having
registered it originally?  In a 'core.postparse' listener, mod_tls registers
a NetIO for the _control_ channel (which means if mod_tls is loaded, mod_proxy
can get it), but what about for the _data_ channels?  Actually, it's looking
like mod_tls uses the same callbacks for its NetIOs, regardless of ctrl vs
data.  BUT those callbacks use mod_tls-specific state that is module-scoped,
NOT stream-scoped (e.g. tls_data_adaptive_bytes, when to renegotiate et al)!
AND mod_proxy will want to be able to use mod_tls' tls_connect() functions
(OR will have to re-implement them itself; sigh).  And what about session
caching, tickets?  Renegotiations?

Note, however, that for:

  client -- (ftps) --> proxy -- (ftp) --> server

The above approach could work very well; this would work for mod_proxy when
reverse proxying, providing a FTPS frontend to legacy FTP servers, for example.
