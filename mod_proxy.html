<html>
<head>
<title>ProFTPD module mod_proxy</title>
</head>

<body bgcolor=white>

<hr>
<center>
<h2><b>ProFTPD module <code>mod_proxy</code></b></h2>
</center>
<hr><br>

<p>
The purpose of the <code>mod_proxy</code> module is to provide FTP proxying
capabilities in <code>proftpd</code>, both <em>reverse</em> (or "gateway")
proxying and <em>forward</em> proxying.

<p>
Installation instructions are discussed <a href="#Installation">here</a>;
detailed notes on best practices for using this module are
<a href="#Usage">here</a>.

<p>
The most current version of <code>mod_proxy</code> can be found at:
<pre>
  <a href="https://github.com/Castaglia/proftpd-mod_proxy.git">https://github.com/Castaglia/proftpd-mod_proxy.git</a>
</pre>

<h2>Author</h2>
<p>
Please contact TJ Saunders &lt;tj <i>at</i> castaglia.org&gt; with any
questions, concerns, or suggestions regarding this module.

<h2>Directives</h2>
<ul>
  <li><a href="#ProxyDataTransferPolicy">ProxyDataTransferPolicy</a>
  <li><a href="#ProxyEngine">ProxyEngine</a>
  <li><a href="#ProxyForwardEnabled">ProxyForwardEnabled</a>
  <li><a href="#ProxyForwardMethod">ProxyForwardMethod</a>
  <li><a href="#ProxyForwardTo">ProxyForwardTo</a>
  <li><a href="#ProxyLog">ProxyLog</a>
  <li><a href="#ProxyOptions">ProxyOptions</a>
  <li><a href="#ProxyReverseConnectPolicy">ProxyReverseConnectPolicy</a>
  <li><a href="#ProxyReverseServers">ProxyReverseServers</a>
  <li><a href="#ProxyRetryCount">ProxyRetryCount</a>
  <li><a href="#ProxyRole">ProxyRole</a>
  <li><a href="#ProxySourceAddress">ProxySourceAddress</a>
  <li><a href="#ProxyTables">ProxyTables</a>
  <li><a href="#ProxyTimeoutConnect">ProxyTimeoutConnect</a>
</ul>

<p>
<hr>
<h2><a name="ProxyDataTransferPolicy">ProxyDataTransferPolicy</a></h2>
<strong>Syntax:</strong> ProxyDataTransferPolicy <em>client|active|passive|pasv|epsv|port|eprt</em><br>
<strong>Default:</strong> ProxyDataTransferPolicy client<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyDataTransferPolicy</code> directive configures the data
transfer <em>policy</em> that <code>mod_proxy</code> uses when performing
data transfers (<i>e.g.</i> file uploads/downloads, directory listings) with
the backend/destination server.

<p>
The currently supported policies are:
<ul>
  <li><code>client</code>
    <p>
    This policy indicates that <code>mod_proxy</code> will use whatever
    the connected client uses.  Thus if the client sends <code>PORT</code>,
    <code>mod_proxy</code> will send <code>PORT</code> to the
    backend/destination server.

    <p>
    This is the <em>recommended policy</em> in most cases.
  </li>

  <p>
  <li><code>active</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <em>active</em> data transfers (<i>i.e.</i> using
    <code>PORT</code> commands) with the backend/destination server.
  </li>

  <p>
  <li><code>passive<code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <em>passive</em> data transfers (<i>i.e.</i> using
    <code>PASV</code> commands) with the backend/destination server.
  </li>

  <p>
  <li><code>PASV</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>PASV</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>PORT</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>PORT</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>EPSV</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>EPSV</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>EPRT</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>EPRT</code> commands with the backend/destination
    server.
  </li>
</ul>

<p>
<hr>
<h2><a name="ProxyEngine">ProxyEngine</a></h2>
<strong>Syntax:</strong> ProxyEngine <em>on|off</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyEngine</code> directive toggles the support for proxying by
<code>mod_proxy</code>.  This is usually used inside a
<code>&lt;VirtualHost&gt;</code> section to enable proxying of FTP sessions for
a particular virtual host. By default <code>mod_proxy</code> is disabled for
both the main server and all configured virtual hosts.

<p>
<hr>
<h2><a name="ProxyForwardEnabled">ProxyForwardEnabled</a></h2>
<strong>Syntax:</strong> ProxyForwardEnabled <em>on|off</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> <code>&lt;Class&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc2 and later

<p>
The <code>ProxyForwardEnabled</code> directive determines whether a client
can use <code>mod_proxy</code> for forward proxying, based on that client's
<a href="http://www.proftpd.org/docs/howto/Classes.html">class</a>.

<p>
By default, <code>mod_proxy</code> rejects any forward proxy request from
<b>any</b> client, with the exception of clients connecting from
<a href="http://www.faqs.org/rfcs/rfc1918.html">RFC 1918</a> addresses:
<pre>
  192.168.0.0/16
  172.16.0.0/12
  10.0.0.0/8
</pre>
This is done as a security measure: <b>open/unrestricted proxy servers are
dangerous both to your network and to the Internet at large</b>.  Thus to make
it possible for clients to use your server for forward proxying, they <b>must
be explicitly</b> enabled to do so.

<p>
Example:
<pre>
  &lt;Class forward-proxy&gt;
    From 1.2.3.4/12

    # Allow clients from this class to use FTP forward proxying
    ProxyForwardEnabled on
  &lt;/Class&gt;
</pre>

<p>
See also: <a href="#ProxyForwardTo"><code>ProxyForwardTo</code></a>

<p>
<hr>
<h2><a name="ProxyForwardMethod">ProxyForwardMethod</a></h2>
<strong>Syntax:</strong> ProxyForwardMethod <em>method</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyForwardMethod</code> directive configures the <em>method</em>
that clients can use for requesting forward proxying.  Some methods require
that the client authenticate <em>to the proxy first</em>, and then separately
authenticate to the destination server; these methods differ on just when
the client specifies the destination server.  Other methods do not require
proxy authentication.  There are many variations on a theme with these methods.

<p>
The currently supported methods are:
<ul>
  <li><code>proxyuser,user@host</code>
    <p>
    This method indicates that proxy authentication is <b>required</b>.  The
    client first authenticates to the proxy via <code>USER/PASS</code> commands:
<pre>
  USER <em>proxy-user</em>
  PASS <em>proxy-passwd</em>
</pre>
    Then the client authenticates <i>again</i>, this time including the
    address (and optionally port) of the destination server as part of the
    second <code>USER</code> command:
<pre>
  USER <em>real-user</em>@ftp.example.com
  PASS <em>real-passwd</em>
</pre>
    The <code>mod_proxy</code> module will remove the destination address
    portion of the second <code>USER</code> command before proxying it to
    the destination server.
  </li>

  <p>
  <li><code>proxyuser@host,user</code>
    <p>
    This method indicates that proxy authentication is <b>required</b>.  The
    client first authenticates to the proxy via <code>USER/PASS</code> commands;
    note that the destination address (and optionally port) is included as part
    of the first <code>USER</code> command:
<pre>
  USER <em>proxy-user</em>@ftp.example.com
  PASS <em>proxy-passwd</em>
</pre>
    Then the client authenticates <i>again</i>, this time sending the
    <code>USER/PASS</code> commands to authenticate to the destination server:
<pre>
  USER <em>real-user</em>
  PASS <em>real-passwd</em>
</pre>
  </li>

  <p>
  <li><code>user@host</code>
    <p>
    This methods indicates that <i>no proxy authentication</i> is used.  The
    client indicates the destination address (and optionally port) of the
    server as part of the <code>USER</code> command:
<pre>
  USER <em>real-user</em>@ftp.example.com
  PASS <em>real-passwd</em>
</pre>
    The <code>mod_proxy</code> module will remove the destination address
    portion of the <code>USER</code> command before proxying it to the
    destination server.
  </li>
</ul>

<p>
Configuring the FTP client's proxy settings to match the above methods varies
greatly, depending on the FTP client.

<p>
<hr>
<h2><a name="ProxyForwardTo">ProxyForwardTo</a></h2>
<strong>Syntax:</strong> ProxyForwardTo <em>[!]pattern [flags]</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyForwardTo</code> directive is used to restrict which
hosts/domains can be requested for forward proxying.  The destination host/port
for forward proxying <b>must</b> match the configured <em>pattern</em>
regular expression, or the forward proxying request will fail.

<p>
The optional <em>flags</em> parameter, if present, modifies how the given
<em>pattern</em> will be evaludated.  The supported flags are:
<ul>
  <li><b>nocase|NC</b> (<b>n</b>o <b>c</b>ase)<br>
      This makes the <em>pattern</em> case-insensitive, <i>i.e.</i> there is
      no difference between 'A-Z' and 'a-z' when <em>pattern</em> is matched
      against the path
  </li>
</ul>

<p>
<code>ProxyForwardTo</code> limits the destination hosts <b>to</b> which
clients can request forward proxying; by contrast,
<a href="#ProxyForwardEnabled"><code>ProxyForwardEnabled</code></a> controls
forward proxying based on where clients connect <b>from</b>.

<p>
<hr>
<h2><a name="ProxyLog">ProxyLog</a></h2>
<strong>Syntax:</strong> ProxyLog <em>path|"none"</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyLog</code> directive is used to specify a log file for
<code>mod_proxy</code>'s reporting on a per-server basis.  The <em>path</em>
parameter given must be the full path to the file to use for logging.

<p>
Note that this path must <b>not</b> be to a world-writable directory and,
unless <code>AllowLogSymlinks</code> is explicitly set to <em>on</em>
(generally a bad idea), the path must <b>not</b> be a symbolic link.

<p>
<hr>
<h2><a name="ProxyOptions">ProxyOptions</a></h2>
<strong>Syntax:</strong> ProxyOptions <em>opt1 ...</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyOptions</code> directive is used to configure various optional
behavior of <code>mod_proxy</code>.  For example:
<pre>
  ProxyOptions UseProxyProtocol
</pre>

<p>
The currently implemented options are:
<ul>
  <li><code>ShowFeatures</code><br>
    <p>
    When reverse proxing, <code>mod_proxy</code> defaults to not responding to
    the FTP <code>FEAT</code> command, which is used to determine the supported
    features/capabilities of the FTP server; this is done to prevent leaking
    of information about internal FTP servers to the outside world.  However,
    some clients rely on the <code>FEAT</code> data.  For such clients/use
    cases, use this option to tell <code>mod_proxy</code> to proxy the
    <code>FEAT</code> command/response to the backend server.
  </li>

  <p>
  <li><code>UseProxyProtocol</code><br>
    <p>
    When <code>mod_proxy</code> connects to the backend/destination server,
    use the <a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt"><code>PROXY</code></a> protocol, sending the human-readable <code>PROXY</code>
    command to the destination server.  This allows backend servers to implement
    access controls/logging, based on the IP address of the connecting client.
    The <a href="https://github.com/Castaglia/proftpd-mod_proxy_protocol"><code>mod_proxy_protocol</code></a>
    ProFTPD module can be used to handle the <code>PROXY</code> command on
    the receiving side, <i>i.e.</i> when using <code>proftpd</code> as the
    backend/destination server.
  </li>
</ul>

<p>
<hr>
<h2><a name="ProxyRetryCount">ProxyRetryCount</a></h2>
<strong>Syntax:</strong> ProxyRetryCount <em>count</em><br>
<strong>Default:</strong> ProxyRetryCount 5<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyRetryCount</code> directive configures the number of times
<code>mod_proxy</code> will attempt to connect to the backend/destination
server.  The default is <em>5</em> attempts.

<p>
<hr>
<h2><a name="ProxyReverseConnectPolicy">ProxyReverseConnectPolicy</a></h2>
<strong>Syntax:</strong> ProxyReverseConnectPolicy <em>policy</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyReverseConnectPolicy</code> directive configures the
<em>policy</em> that <code>mod_proxy</code> will use for selecting the backend
server when reverse proxying.

<p>
The currently supported policies are:
<ul>
  <li><code>LeastConns</code>
    <p>
    Select the backend server with the lowest number of proxied connections.
  </li>

  <p>
  <li><code>PerHost</code>
    <p>
    Select a backend server based on the IP address of the connecting client;
    any future connections from that IP address will be routed to the same
    backend server.
  </li>

  <p>
  <li><code>PerUser</code>
    <p>
    Select a backend server based on the <code>USER</code> name used by the
    connecting client; any future connections using that same <code>USER</code>
    name will be routed to the same backend server.
  </li>

  <p>
  <li><code>Random</code>
    <p>
    Randomly select any of the backend servers.
  </li>

  <p>
  <li><code>RoundRobin</code>
    <p>
    Select the next backend server in the list.
  </li>

  <p>
  <li><code>Shuffle</code>
    <p>
    Similar to the <code>Random</code> policy, except the selection happens
    from the not-yet-chosed backend servers.  This means that <b>all</b>
    backend servers will eventually be used evenly, just in a random order.
  </li>
</li>

<p>
<hr>
<h2><a name="ProxyReverseServers">ProxyReverseServers</a></h2>
<strong>Syntax:</strong> ProxyReverseServers <em>servers</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyReverseServers</code> directive configures the list of servers
to be used as the backend servers for reverse proxying.

<p>
Each server <b>must</b> be configured as a <i>URL</i>.  Only the "ftp" scheme
is currently supported.  If not specified, the port will be 21.  IPv6 addresses
<b>must</b> be enclosed within square brackets.  Thus, for example, the
following are all valid URLs:
<pre>
  ftp://<em>ftp1.example.com:2121</em>
  ftp://<em>1.2.3.4</em>
  ftp://<em>[::ffff:6.7.8.9]:2121</em>
</pre>
And using them all in the configuration would look like:
<pre>
  ProxyReverseServers ftp://ftp1.example.com:2121 ftp://1.2.3.4 ftp://[::ffff:6.7.8.9]:2121
</pre>

<p>
In addition, the list of backend servers can be contained in a simple text
file, one URL per line; you then only need to configure the path to that
text file:
<pre>
  ProxyReverseServers file:/path/to/backends.txt
</pre>

<p>
<hr>
<h2><a name="ProxyRole">ProxyRole</a></h2>
<strong>Syntax:</strong> ProxyRole <em>role</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyRole</code> directive configures whether <code>mod_proxy</code>
will perform forward or reverse proxying.  The list of supported <em>roles</em>
are thus:
<ul>
  <li><code>forward</code>
    <p>
    Perform forward proxying.
  </li>

  <p>
  <li><code>reverse</code>
    <p>
    Perform reverse proxying.
  </li>
</ul>

<p>
<b>Note</b> that the <code>ProxyRole</code> directive is <b>required</b>
for <code>mod_proxy</code> to function.  If this directive is not configured,
connections to <code>mod_proxy</code> will fail.

<p>
<hr>
<h2><a name="ProxySourceAddress">ProxySourceAddress</a></h2>
<strong>Syntax:</strong> ProxySourceAddress <em>address</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxySourceAddress</code> directive configures the <em>address</em>
(or <em>device name</em>) of a network interface on the host machine, to
be used when connecting to the backend/destination server.  This directive
is most useful on a multi-homed (or DMZ) host; frontend connections can
be received on one network interface, and the backend connections can use
a different network interface.  Imagine <i>e.g.</i> separate WAN/LAN interfaces
on a proxying host.

<p>
<hr>
<h2><a name="ProxyTables">ProxyTables</a></h2>
<strong>Syntax:</strong> ProxyTables <em>table-info</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyTables</code> directive is used to specify a directory that
<code>mod_proxy</code> will use for storing its database files; these files
are used for tracking the various load balancing/healthcheck statistics used
for proxying.

<p>
<b>Note</b> that the <code>ProxyTables</code> directive is <b>required</b>
for <code>mod_proxy</code> to function.  If this directive is not configured,
connections to <code>mod_proxy</code> will fail.

<p>
<hr>
<h2><a name="ProxyTimeoutConnect">ProxyTimeoutConnect</a></h2>
<strong>Syntax:</strong> ProxyTimeoutConnect <em>timeout</em><br>
<strong>Default:</strong> ProxyTimeoutConnect 5sec<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyTimeoutConnect</code> directive configures the amount of time
that <code>mod_proxy</code> will wait for the backend/destination server to
accept a TCP connection, before giving up.

<p>
Note that if there are many different backend/destination servers to try
(due to <i>e.g.</i> <code>ProxyRetryCount</code>), <i>and</i> if those
backend servers are slow, the connecting client might itself see connection
timeouts to <code>mod_proxy</code>.  To guard against such slow backend
servers, a more aggressively short timeout can be used:
<pre>
  ProxyTimeoutConnect 1sec
</pre>

<p>
<hr>
<h2><a name="Usage">Usage</a></h2>

<p>
<b>Benefits of Proxying</b><br>
The benefits of using a module like <code>mod_proxy</code> depend mostly
on the type of proxying, forward or reverse, that <code>mod_proxy</code>
is configured to perform.  There are some benefit, however, that the module
can bring, regardless of the type of proxying:
<ul>
  <li>Add ProFTPD's logging power (<code>TransferLog</code>, <code>ExtendedLog</code>, <i>etc</i>) for FTP servers which do not provide such versatile logging
  <li>Use ProFTPD's monitoring capabilities (<i>e.g.</i> <code>mod_snmp</code>) for FTP servers which do not have such features
</ul>

<p>
<i>Forward Proxying</i><br>
One of the most common benefits of a forward proxy is having controlled access,
by clients within an internal LAN, to outside servers.  FTP makes this sort
of thing notoriously difficult for firewalls/routers due to its multi-TCP
connection nature; this, in turn, makes proxying of FTP more difficult.  But
<code>mod_proxy</code> makes this possible; it understands FTP, and thus
provides the access control needed for such use cases.

<p>
When using <code>mod_proxy</code> as a forward proxy, FTP clients which can
only perform active data transfers can use <code>mod_proxy</code> as a way
to use passive data transfers with the destination FTP server.

<p>
Similarly, FTP clients which do not support IPv6 can proxy through
<code>mod_proxy</code> to reach a destination FTP server with an IPv6 address;
<code>mod_proxy</code> handles IPv4 and IPv6 addresses transparently.

<p>
<i>Reverse Proxying</i><br>
Just as <code>mod_proxy</code> can aid naive/legacy FTP clients via forward
proxying, <code>mod_proxy</code> can similarly front legacy FTP servers.
For example, <code>mod_proxy</code> can sit in front of FTP servers which
do not handle IPv6 addresses, and provide this functionality transparently
to IPv6-capable FTP clients.

<p>
When performing reverse proxying, <code>mod_proxy</code> can also perform
load balancing in various ways.  The common methods of "round robin" and
"least connections" are implemented; <code>mod_proxy</code> also provides
"sticky session" load balancing of clients as well.

<p>
<b>Handling of Proxied Sessions</b><br>
Once a proxied session has authenticated with the backend/destination server,
the <code>mod_proxy</code> module automatically chroots itself to a
subdirectory of the <a href="#ProxyTables"><code>ProxyTables</code></a>
directory, after which all root privileges are permanently dropped.

<p>
<b>Forward Proxy Configuration</b><br>
Before discussing example forward proxy configurations for
<code>mod_proxy</code>, it is very important to understand the consequences
of providing forward proxy capabilities.

<p>
<b>Important Security Considerations</b><br>
A forward proxy can be used by <b>any</b> client to have <em>the proxy</em>
connect to <b>any</b> arbitrary host, while hiding the client's true identity.
Malicious behavior, hacking or denial-of-service attempts, <i>etc</i> will
appear to be coming from <em>your proxy</em>; this is dangerous for your
network, and for the Internet at large.  Think of the damage that has been
done, <em>and continues to happen</em>, due to open/unrestricted proxies/relays
such as open DNS or SMTP/email proxies.

<p>
This is the reason that <code>mod_proxy</code> does not allow just <b>any</b>
client to use its forward proxy capabilities by default; instead, only
clients connecting from the LAN are allowed by default.  Allowing trusted
outside clients is done using the
<a href="#ProxyForwardEnabled"><code>ProxyForwardEnabled</code></a> directive.
Even allowing internal clients to use your forward proxy can be troublesome,
depending on the destination hosts selected by the clients.  To ensure that
your clients are using the forward proxy to connect only to the hosts allowed,
you can use the <a href="#ProxyForwardTo"><code>ProxyForwardTo</code></a>
directive to configure a regular expression-based whitelist of allowed
destination/target hosts; <b>this is strongly recommended</b>.

<p>
With all that said, here's an example <code>mod_proxy</code> configuration
for supporting forward proxying:
<pre>
  &lt;IfModule mod_proxy.c&gt;
    ProxyEngine on
    ProxyLog /path/to/proxy.log
    ProxyTables /var/ftp/proxy

    ProxyRole forward
    ProxyForwardMethod user@host
    ProxyForwardTo ^ftp\.example\.com [NC]
  &lt;/IfModule&gt;
</pre>

<p>
<b>Reverse Proxy Configuration</b><br>
Reverse proxies (also known as "gateways") are often used to provide access
to FTP resources, located with internal networks, to the outside world.  The
reverse proxy can perform load balancing, provide functionality that the
internal servers may not be able to do, and even perform things like caching.

<p>
Access control for reverse proxies is less critical than for forward proxies
because clients can only reach, via the reverse proxy, the backend servers
that the reverse proxy has been configured to use; the clients do <b>not</b>
get to choose arbitrary hosts for the reverse proxy to use.

<p>
Here's an example <code>mod_proxy</code> configuration for supporting reverse
proxying:
<pre>
  &lt;IfModule mod_proxy.c&gt;
    ProxyEngine on
    ProxyLog /path/to/proxy.log
    ProxyTables /var/ftp/proxy

    ProxyRole reverse
    ProxyReverseConnectPolicy RoundRobin
    ProxyReverseServers ftp://ftp-backend1.example.com:2121 ftp://ftp-backend2.example.com:2121 ...
  &lt;/IfModule&gt;
</pre>

<p>
Here's an example <code>mod_proxy</code> configuration for reverse proxying,
with lookup of per-user backend servers:
<pre>
<pre>
  &lt;IfModule mod_proxy.c&gt;
    ProxyEngine on
    ProxyLog /path/to/proxy.log
    ProxyTables /var/ftp/proxy

    ProxyRole reverse
    ProxyReverseConnectPolicy PerUser

    # We need to provide a pool of backend servers as a fallback
    ProxyReverseServers ftp://ftp-backend1.example.com:2121 ftp://ftp-backend2.example.com:2121 ...

    # Look up per-user backend servers from user-specific files
    ProxyReverseServers file:/var/ftp/proxy/backends/%U.txt
  &lt;/IfModule&gt;
</pre>

<p>
<b>Load Balancing versus Session Stickiness</b><br>
For reverse proxy configurations, there is a choice between
<em>load balancing</em> and <em>sticky session</em>
<code>ProxyReverseConnectPolicy</code> parameters; these parameters determine
the selection of the backend server that will handle the incoming connection.

<p>
Which should you use, and why?

<p>
All of the <em>balancing</em> policies are able to select the backend server
<em>when the FTP client connects to the proxy, before sending any commands</em>.
Most of the "sticky" policies, on the other hand, require more knowledge about
the user (<i>e.g.</i> <code>USER</code> name, <code>HOST</code> name, SSL
session ID) <em>before the backend server can be determined</em>, thus backend
server selection is delayed until that information is obtained.

<p>
<em>Balancing</em> is best when all of your backend severs are identical with
regard to the content they have, <b>and</b> when it does not matter which
server handles a particular client.  Maybe all of your backend servers use a
shared filesystem via NFS or similar, thus directory listings will be the same
for a user no matter which backend server is used, and uploading files to one
server means that those files can be downloaded/seen by the other servers.
Balancing policies are also best when all of your backend servers have similar
processing power (memory, CPU, network, disk), so that all backend servers
are equally capable of providing the same service to the connecting client.

<p>
The <em>balancing</em> policies are:
<ul>
  <li><code>LeastConns</code>
  <li><code>Random</code>
  <li><code>RoundRobin</code>
  <li><code>Shuffle</code>
</ul>

<p>
<em>Stickiness</em> is best when your backend servers are <b>not</b> identical,
and some users/clients <em>should only ever go to the same set of backend
servers</em>.  Thus the user/client needs to be "sticky" to a given backend
server.

<p>
The <em>sticky</em> policies are:
<ul>
  <li><code>PerHost</code>
  <li><code>PerUser</code>
</ul>

<p>
<b>SFTP/SCP Support</b><br>
The <code>mod_proxy</code> module only works for FTP/FTPS sessions; it does
<b>not</b> currently support/handle SFTP/SCP sessions.

<p>
<b>Logging</b><br>
The <code>mod_proxy</code> module supports different forms of logging.  The
main module logging is done via the
<a href="#ProxyLog"><code>ProxyLog</code></a> directive.  For debugging
purposes, the module also uses <a href="http://www.proftpd.org/docs/howto/Tracing.html">trace logging</a>, via the module-specific channels:
<ul>
  <li>proxy
  <li>proxy.conn
  <li>proxy.db
  <li>proxy.forward
  <li>proxy.ftp.conn
  <li>proxy.ftp.ctrl
  <li>proxy.ftp.data
  <li>proxy.ftp.msg
  <li>proxy.ftp.sess
  <li>proxy.ftp.xfer
  <li>proxy.reverse
  <li>proxy.session
  <li>proxy.uri
</ul>
Thus for trace logging, to aid in debugging, you would use the following in
your <code>proftpd.conf</code>:
<pre>
  TraceLog /path/to/proxy-trace.log
  Trace proxy:20
</pre>
This trace logging can generate large files; it is intended for debugging
use only, and should be removed from any production configuration.

<p><a name="Wishlist">
<b>Suggested Future Features</b><br>
The following lists the features I hope to add to <code>mod_proxy</code>,
according to need, demand, inclination, and time:
<ul>
  <li>FTPS connections to backend/destination servers
  <li>Directory format translation (<i>e.g.</i> <code>LIST</code> to <code>MLSD</code>)
  <li>SFTP/SCP support
</ul>
See the GitHub <a href="https://github.com/Castaglia/proftpd-mod_proxy/issues">issues</a> page for current bugs and feature requests, and to report issues.

<p><a name="FAQ">
<b>Frequently Asked Questions</b><br>

<p><a name="ProxyRoundRobinVsLeastConns">
<font color=red>Question</font>: I have heard a lot about both "round robin"
and "least conns" for load balancing.  Which is better for FTP connections?><br>
<font color=blue>Answer</font>:  There is not an easy answer to this, because
it really comes down to the type of traffic that your FTP servers will see.

<p>
<b><i>If</i></b> your FTP sessions tend to be long-lived (<i>e.g.</i> on the
order of minutes to hours), then using <code>ProxyReverseConnectPolicy
LeastConns</code> will tend to provide the best distribution of those sessions
across your pool of backend servers.  The assumption here is that <b>new</b>
connections arrive infrequently <em>relative to the number of existing
connections</em>.

<p>
On the other hand, <b><i>if</i></b> your FTP sessions tend to be shorter
(<i>e.g.</i> minutes at most), then using <code>ProxyReverseConnectPolicy
RoundRobin</code> might provide a more even distribution of connections
across your pool of backend servers.

<p><a name="ProxyPerHostBackendServers">
<font color=red>Question</font>: I am using:
<pre>
  ProxyReverseConnectPolicy PerHost
</pre>
and would like to configure different pools of backend servers for different
incoming clients.  How do I do this?<br>
<font color=blue>Answer</font>:  The best way to achieve this would be
to use <a href="http://www.proftpd.org/docs/howto/Classes.html">classes</a>
and <code>mod_ifsession</code>'s <code>&lt;IfClass&gt;</code> sections.  For
example:
<pre>
  &lt;Class proxied-clients&gt;
  &lt;/Class&gt;

  ProxyRole reverse
  ProxyReverseConnectPolicy PerHost

  &lt;IfClass proxied-clients&gt;
    ProxyReverseServers ftp://ftp-special1.example.com:2121 ftp://ftp-special2.example.com:2121 ...
  &lt;/IfClass&gt;

  # Don't forget to configure the backend server pool for clients coming
  # from other networks!
  &lt;IfClass !proxied-clients&gt;
    ProxyReverseServers ftp://ftp-backend1.example.com:2121 ftp://ftp-backend2.example.com:2121 ...
  &lt;/IfClass&gt;
</pre>

<p>
<hr>
<h2><a name="Installation">Installation</a></h2>
To install <code>mod_proxy</code>, go to the third-party module area in
the proftpd source code and unpack the <code>mod_proxy</code> source tarball:
<pre>
  cd <i>proftpd-dir</i>/contrib/
  tar zxvf /path/to/mod_proxy-<i>version</i>.tar.gz
</pre>
after unpacking the latest proftpd-1.3.<i>x</i> source code.  For including
<code>mod_proxy</code> as a staticly linked module:
<pre>
  ./configure --with-modules=mod_proxy:...
</pre>
To build <code>mod_proxy</code> as a DSO module:
<pre>
  ./configure --enable-dso --with-shared=mod_proxy:...
</pre>
Then follow the usual steps:
<pre>
  make
  make install
</pre>

<p>
<hr>

<font size=2><b><i>
&copy; Copyright 2015 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr>
</body>
</html>
