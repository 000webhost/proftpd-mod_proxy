<html>
<head>
<title>ProFTPD module mod_proxy</title>
</head>

<body bgcolor=white>

<hr>
<center>
<h2><b>ProFTPD module <code>mod_proxy</code></b></h2>
</center>
<hr><br>

<p>
The purpose of the <code>mod_proxy</code> module is to provide FTP proxying
capabilities in <code>proftpd</code>, both <em>reverse</em> (or "gateway")
proxying and <em>forward</em> proxying.

<p>
Installation instructions are discussed <a href="#Installation">here</a>;
detailed notes on best practices for using this module are
<a href="#Usage">here</a>.

<p>
The most current version of <code>mod_proxy</code> can be found at:
<pre>
  <a href="https://github.com/Castaglia/proftpd-mod_proxy.git">https://github.com/Castaglia/proftpd-mod_proxy.git</a>
</pre>

<h2>Author</h2>
<p>
Please contact TJ Saunders &lt;tj <i>at</i> castaglia.org&gt; with any
questions, concerns, or suggestions regarding this module.

<h2>Directives</h2>
<ul>
  <li><a href="#ProxyDataTransferPolicy">ProxyDataTransferPolicy</a>
  <li><a href="#ProxyEngine">ProxyEngine</a>
  <li><a href="#ProxyForwardEnabled">ProxyForwardEnabled</a>
  <li><a href="#ProxyForwardMethod">ProxyForwardMethod</a>
  <li><a href="#ProxyForwardTo">ProxyForwardTo</a>
  <li><a href="#ProxyLog">ProxyLog</a>
  <li><a href="#ProxyOptions">ProxyOptions</a>
  <li><a href="#ProxyReverseConnectPolicy">ProxyReverseConnectPolicy</a>
  <li><a href="#ProxyReverseServers">ProxyReverseServers</a>
  <li><a href="#ProxyRetryCount">ProxyRetryCount</a>
  <li><a href="#ProxyRole">ProxyRole</a>
  <li><a href="#ProxySourceAddress">ProxySourceAddress</a>
  <li><a href="#ProxyTables">ProxyTables</a>
  <li><a href="#ProxyTimeoutConnect">ProxyTimeoutConnect</a>
</ul>

<p>
<hr>
<h2><a name="ProxyDataTransferPolicy">ProxyDataTransferPolicy</a></h2>
<strong>Syntax:</strong> ProxyDataTransferPolicy <em>client|active|passive|pasv|epsv|port|eprt</em><br>
<strong>Default:</strong> ProxyDataTransferPolicy client<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyDataTransferPolicy</code> directive configures the data
transfer <em>policy</em> that <code>mod_proxy</code> uses when performing
data transfers (<i>e.g.</i> file uploads/downloads, directory listings) with
the backend/destination server.

<p>
The currently supported policies are:
<ul>
  <li><code>client</code>
    <p>
    This policy indicates that <code>mod_proxy</code> will use whatever
    the connected client uses.  Thus if the client sends <code>PORT</code>,
    <code>mod_proxy</code> will send <code>PORT</code> to the
    backend/destination server.

    <p>
    This is the <em>recommended policy</em> in most cases.
  </li>

  <p>
  <li><code>active</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <em>active</em> data transfers (<i>i.e.</i> using
    <code>PORT</code> commands) with the backend/destination server.
  </li>

  <p>
  <li><code>passive<code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <em>passive</em> data transfers (<i>i.e.</i> using
    <code>PASV</code> commands) with the backend/destination server.
  </li>

  <p>
  <li><code>PASV</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>PASV</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>PORT</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>PORT</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>EPSV</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>EPSV</code> commands with the backend/destination
    server.
  </li>

  <p>
  <li><code>EPRT</code>
    <p>
    Regardless of the commands sent by the client, <code>mod_proxy</code>
    will use only <code>EPRT</code> commands with the backend/destination
    server.
  </li>
</ul>

<p>
<hr>
<h2><a name="ProxyEngine">ProxyEngine</a></h2>
<strong>Syntax:</strong> ProxyEngine <em>on|off</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyEngine</code> directive toggles the support for proxying by
<code>mod_proxy</code>.  This is usually used inside a
<code>&lt;VirtualHost&gt;</code> section to enable proxying of FTP sessions for
a particular virtual host. By default <code>mod_proxy</code> is disabled for
both the main server and all configured virtual hosts.

<p>
<hr>
<h2><a name="ProxyForwardEnabled">ProxyForwardEnabled</a></h2>
<strong>Syntax:</strong> ProxyForwardEnabled <em>on|off</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> <code>&lt;Class&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc2 and later

<p>
The <code>ProxyForwardEnabled</code> directive determines whether a client
can use <code>mod_proxy</code> for forward proxying, based on that client's
<a href="http://www.proftpd.org/docs/howto/Classes.html">class</a>.

<p>
By default, <code>mod_proxy</code> rejects any forward proxy request from
<b>any</b> client, with the exception of clients connecting from
<a href="http://www.faqs.org/rfcs/rfc1918.html">RFC 1918</a> addresses:
<pre>
  192.168.0.0/16
  172.16.0.0/12
  10.0.0.0/8
</pre>
This is done as a security measure: <b>open/unrestricted
proxy servers are dangerous both to your network and to the Internet at
large</b>.  Thus to make it possible for clients to use your server for
forward proxying, they must be <b>explicitly</b> enabled to do so.

<p>
Example:
<pre>
  &lt;Class forward-proxy&gt;
    From 1.2.3.4/12

    # Allow clients from this class to use FTP forward proxying
    ProxyForwardEnabled on
  &lt;/Class&gt;
</pre>

<p>
See also: <a href="#ProxyForwardTo"><code>ProxyForwardTo</code></a>

<p>
<hr>
<h2><a name="ProxyForwardMethod">ProxyForwardMethod</a></h2>
<strong>Syntax:</strong> ProxyForwardMethod <em>method</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyForwardMethod</code> directive configures the <em>method</em>
that clients can use for requesting forward proxying.  Some methods require
that the client authenticate <em>to the proxy first</em>, and then separately
authenticate to the destination server; these methods differ on just when
the client specifies the destination server.  Other methods do not require
proxy authentication.  There are many variations on a theme with these methods.

<p>
The currently supported methods are:
<ul>
  <li><code>proxyuser,user@host</code>
    <p>
    This method indicates that proxy authentication is <b>required</b>.  The
    client first authenticates to the proxy via <code>USER/PASS</code> commands:
<pre>
  USER <em>proxy-user</em>
  PASS <em>proxy-passwd</em>
</pre>
    Then the client authenticates <i>again</i>, this time including the
    address (and optionally port) of the destination server as part of the
    second <code>USER</code> command:
<pre>
  USER <em>real-user</em>@ftp.example.com
  PASS <em>real-passwd</em>
</pre>
    The <code>mod_proxy</code> module will remove the destination address
    portion of the second <code>USER</code> command before proxying it to
    the destination server.
  </li>

  <p>
  <li><code>proxyuser@host,user</code>
    <p>
    This method indicates that proxy authentication is <b>required</b>.  The
    client first authenticates to the proxy via <code>USER/PASS</code> commands;
    note that the destination address (and optionally port) is included as part
    of the first <code>USER</code> command:
<pre>
  USER <em>proxy-user</em>@ftp.example.com
  PASS <em>proxy-passwd</em>
</pre>
    Then the client authenticates <i>again</i>, this time sending the
    <code>USER/PASS</code> commands to authenticate to the destination server:
<pre>
  USER <em>real-user</em>
  PASS <em>real-passwd</em>
</pre>
  </li>

  <p>
  <li><code>user@host</code>
    <p>
    This methods indicates that <i>no proxy authentication</i> is used.  The
    client indicates the destination address (and optionally port) of the
    server as part of the <code>USER</code> command:
<pre>
  USER <em>real-user</em>@ftp.example.com
  PASS <em>real-passwd</em>
</pre>
    The <code>mod_proxy</code> module will remove the destination address
    portion of the <code>USER</code> command before proxying it to the
    destination server.
  </li>
</ul>

<p>
Configuring the FTP client's proxy settings to match the above methods varies
greatly, depending on the FTP client.

<p>
<hr>
<h2><a name="ProxyForwardTo">ProxyForwardTo</a></h2>
<strong>Syntax:</strong> ProxyForwardTo <em>[!]pattern [flags]</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyForwardTo</code> directive is used to restrict which
hosts/domains can be requested for forward proxying.  The destination host/port
for forward proxying <b>must</b> match the configured <em>pattern</em>
regular expression, or the forward proxying request will fail.

<p>
The optional <em>flags</em> parameter, if present, modifies how the given
<em>pattern</em> will be evaludated.  The supported flags are:
<ul>
  <li><b>nocase|NC</b> (<b>n</b>o <b>c</b>ase)<br>
      This makes the <em>pattern</em> case-insensitive, <i>i.e.</i> there is
      no difference between 'A-Z' and 'a-z' when <em>pattern</em> is matched
      against the path
  </li>
</ul>

<p>
<code>ProxyForwardTo</code> limits the destination hosts <b>to</b> which
clients can request forward proxying; by contrast,
<a href="#ProxyForwardEnabled"><code>ProxyForwardEnabled</code></a> controls
forward proxying based on where clients connect <b>from</b>.

<p>
<hr>
<h2><a name="ProxyLog">ProxyLog</a></h2>
<strong>Syntax:</strong> ProxyLog <em>path|"none"</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyLog</code> directive is used to specify a log file for
<code>mod_proxy</code>'s reporting on a per-server basis.  The <em>path</em>
parameter given must be the full path to the file to use for logging.

<p>
Note that this path must <b>not</b> be to a world-writable directory and,
unless <code>AllowLogSymlinks</code> is explicitly set to <em>on</em>
(generally a bad idea), the path must <b>not</b> be a symbolic link.

<p>
<hr>
<h2><a name="ProxyOptions">ProxyOptions</a></h2>
<strong>Syntax:</strong> ProxyOptions <em>opt1 ...</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyOptions</code> directive is used to configure various optional
behavior of <code>mod_proxy</code>.  For example:
<pre>
  ProxyOptions UseProxyProtocol
</pre>

<p>
The currently implemented options are:
<ul>
  <li><code>UseProxyProtocol</code><br>
    <p>
    When <code>mod_proxy</code> connects to the backend/destination server,
    it will use the <a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt"><code>PROXY</code></a> protocol, sending the human-readable
    <code>PROXY</code> command to the destination server.  This allows
    backend servers to implement access controls/logging, based on the
    IP address of the connecting (and proxied) client.  The <a href="https://github.com/Castaglia/proftpd-mod_proxy_protocol"><code>mod_proxy_protocol</code></a>
    ProFTPD module can be used to handle the <code>PROXY</code> command on
    the receiving side, <i>i.e.</i> when using <code>proftpd</code> as the
    backend/destination server.
  </li>
</ul>

<p>
<hr>
<h2><a name="ProxyRetryCount">ProxyRetryCount</a></h2>
<strong>Syntax:</strong> ProxyRetryCount <em>count</em><br>
<strong>Default:</strong> ProxyRetryCount 5<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyRetryCount</code> directive configures the number of times
<code>mod_proxy</code> will attempt to connect to the backend/destination
server.  The default is <em>5</em> attempts.

<p>
<hr>
<h2><a name="ProxyReverseConnectPolicy">ProxyReverseConnectPolicy</a></h2>
<strong>Syntax:</strong> ProxyReverseConnectPolicy <em>policy</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyReverseConnectPolicy</code> directive configures the
<em>policy</em> that <code>mod_proxy</code> will use for selecting the backend
server when reverse proxying.

<p>
The currently supported policies are:
<ul>
  <li><code>LeastConns</code>
    <p>
    Select the backend server with the lowest number of proxied connections.
  </li>

  <p>
  <li><code>Random</code>
    <p>
    Randomly select any of the backend servers.
  </li>

  <p>
  <li><code>RoundRobin</code>
    <p>
    Select the next backend server in the list.
  </li>

  <p>
  <li><code>Shuffle</code>
    <p>
    Similar to the <code>Random</code> policy, except the selection happens
    from the not-yet-chosed backend servers.  This means that <b>all</b>
    backend servers will eventually be used evenly, just in a random order.
  </li>
</li>

<p>
<hr>
<h2><a name="ProxyReverseServers">ProxyReverseServers</a></h2>
<strong>Syntax:</strong> ProxyReverseServers <em>servers</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyReverseServers</code> directive configures the list of servers
to be used as the backend servers for reverse proxying.

<p>
Each server <b>must</b> be configured as a <i>URL</i>.  Only the "ftp" scheme
is currently supported.  If not specified, the port will be 21.  IPv6 addresses
<b>must</b> be enclosed within square brackets.  Thus, for example, the
following are all valid URLs:
<pre>
  ftp://<em>ftp1.example.com:2121</em>
  ftp://<em>1.2.3.4</em>
  ftp://<em>[::ffff:6.7.8.9]:2121</em>
</pre>
And using them all in the configuration would look like:
<pre>
  ProxyReverseServers ftp://ftp1.example.com:2121 ftp://1.2.3.4 ftp://[::ffff:6.7.8.9]:2121
</pre>

<p>
In addition, the list of backend servers can be contained in a simple text
file, one URL per line; you then only need to configure the path to that
text file:
<pre>
  ProxyReverseServers file:/path/to/backends.txt
</pre>

<p>
<hr>
<h2><a name="ProxyRole">ProxyRole</a></h2>
<strong>Syntax:</strong> ProxyRole <em>role</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyRole</code> directive configures whether <code>mod_proxy</code>
will perform forward or reverse proxying.  The list of supported <em>roles</em>
are thus:
<ul>
  <li><code>forward</code>
    <p>
    Perform forward proxying.
  </li>

  <p>
  <li><code>reverse</code>
    <p>
    Perform reverse proxying.
  </li>
</ul>

<p>
<b>Note</b> that the <code>ProxyRole</code> directive is <b>required</b>
for <code>mod_proxy</code> to function.  If this directive is not configured,
connections to <code>mod_proxy</code> will fail.

<p>
<hr>
<h2><a name="ProxySourceAddress">ProxySourceAddress</a></h2>
<strong>Syntax:</strong> ProxySourceAddress <em>address</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxySourceAddress</code> directive configures the <em>address</em>
(or <em>device name</em>) of a network interface on the host machine, to
be used when connecting to the backend/destination server.  This directive
is most useful on a multi-homed (or DMZ) host; frontend connections can
be received on one network interface, and the backend connections can use
a different network interface.  Imagine <i>e.g.</i> separate WAN/LAN interfaces
on a proxying host.

<p>
<hr>
<h2><a name="ProxyTables">ProxyTables</a></h2>
<strong>Syntax:</strong> ProxyTables <em>table-info</em><br>
<strong>Default:</strong> None<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyTables</code> directive is used to specify a directory that
<code>mod_proxy</code> will use for storing its database files; these files
are used for tracking the various load balancing/healthcheck statistics used
for proxying.

<p>
<hr>
<h2><a name="ProxyTimeoutConnect">ProxyTimeoutConnect</a></h2>
<strong>Syntax:</strong> ProxyTimeoutConnect <em>timeout</em><br>
<strong>Default:</strong> ProxyTimeoutConnect 5sec<br>
<strong>Context:</strong> server config, <code>&lt;VirtualHost&gt;</code>, <code>&lt;Global&gt;</code><br>
<strong>Module:</strong> mod_proxy<br>
<strong>Compatibility:</strong> 1.3.6rc1 and later

<p>
The <code>ProxyTimeoutConnect</code> directive configures the amount of time
that <code>mod_proxy</code> will wait for the backend/destination server to
accept a TCP connection, before giving up.

<p>
Note that if there are many different backend/destination servers to try
(due to <i>e.g.</i> <code>ProxyRetryCount</code>), <i>and</i> if those
backend servers are slow, the connecting client might itself see connection
timeouts to <code>mod_proxy</code>.  To guard against such slow backend
servers, a more aggressively short timeout can be used:
<pre>
  ProxyTimeoutConnect 1sec
</pre>

<p>
<hr>
<h2><a name="Usage">Usage</a></h2>

<p>
<b>Benefits</b><br>

  Front servers which can't do: PASV, EPRT/EPSV, FTPS
  Can use to do your logging: TransferLog, ExtendedLog, mod_log_zmq, etc.
  Can use to do your monitoring: mod_snmp, etc

  use mod_proxy with an active data transfer only client with passive only
  servers

  use mod_proxy in forward mode to add "IPv6" capability, i.e. talk to IPv6
  server, for IPv4-only client.

NOT YET:
  use mod_proxy in forward mode to add SSL/TLS capability, i.e. to talk to
  FTPS server, for non-SSL/TLS clients?

<p>
<b>Handling Proxied Sessions</b><br>

automatically <b>chroot</b> itself to a subdirectory of the
<code>ProxyTables</code> directory, after which all root privileges are
permanently dropped.

<p>
<b>Example Forward Proxy Configuration</b><br>

<p>
<b>Important Security Considerations</b><br>
Strictly limiting access is essential if you are using a forward proxy (using the ProxyRequests directive). Otherwise, your server can be used by any client to access arbitrary hosts while hiding his or her true identity. This is dangerous both for your network and for the Internet at large. When using a reverse proxy (using the ProxyPass directive with ProxyRequests Off), access control is less critical because clients can only contact the hosts that you have specifically configured.

  ProxyForwardEnabled
  ProxyForwardTo

  Keep this restricted, as it can be used to "hide" the origin of attacks,
  using your proxy as the jumping off point.  Think of open email relays.

<pre>
  &lt;IfModule mod_proxy.c&gt;
    ProxyEngine on
    ProxyLog /path/to/proxy.log

    ProxyForwardMethod ...
    ProxyForwardTo ...
  &lt;/IfModule&gt;
</pre>

<p>
<b>Example Reverse Proxy Configuration</b><br>
<pre>
  &lt;IfModule mod_proxy.c&gt;
    ProxyEngine on
    ProxyLog /path/to/proxy.log

    ProxyReverseServers ...
    ProxyReverseConnectPolicy ...
  &lt;/IfModule&gt;
</pre>

<p>
<b>Secure/Paranoid Configurations</b><br>

Automatically chroots to ProxyTables/empty/ directory

<p>
<b>Balancing vs Stickiness</b><br>
For reverse proxy configurations, there is a choice between <em>balancing</em>
and <em>sticky</em> <code>ProxyReverseConnectPolicy</code> parameters, when it
comes to selecting the backend server that will handle the incoming connection.

<p>
Which should you use, and why?

<p>
All of the <em>balancing</em> policies are able to select the backend server
<em>when the FTP client connects to the proxy, before sending any commands</em>.
Most of the "sticky" policies, on the other hand, require more knowledge about
the user (<i>e.g.</i> USER name, HOST name, SSL session ID) <em>before the
backend server can be determined</em>, thus backend server selection is
delayed until that information is obtained.

<p>
<em>Balancing</em> is best when all of your backend severs are identical with
regard to the content they have, <b>and</b> when it does not matter which
server handles a particular client.  Maybe all of your backend servers use a
shared filesystem via NFS or similar, thus directory listings will be the same
for a user no matter which backend server is used, and uploading files to one
server means that those files can be downloaded/seen by the other servers.
The <em>balancing</em> policies are:
<ul>
  <li><code>LeastConns</code>
  <li><code>Random</code>
  <li><code>RoundRobin</code>
  <li><code>Shuffle</code>
</ul>

  "RoundRobin is suitable where all available servers are assumed to be
   largely similar in functionality.  Weighed/ratio'd RoundRobin builds
   weights into the system to deal with heterogenous capacity of the
   servers.  (This is harder, since the "weight" factor is admin-assigned,
   and how exactly is it computed?  2x CPU?  4x memory?  6x network?)

RoundRobin Vs LeastConns; Which is better?

What's better for FTP, SFTP connections?  RoundRobin or LeastConns?  And
why?  The HAproxy docs for the 'balance' keyword say that 'leastconn' is
best for long-lived connections:
    
  leastconn   The server with the lowest number of connections receives the
              connection. Round-robin is performed within groups of servers
              of the same load to ensure that all servers will be used. Use
              of this algorithm is recommended where very long sessions are
              expected, such as LDAP, SQL, TSE, etc... but is not very well
              suited for protocols using short sessions such as HTTP. This
              algorithm is dynamic, which means that server weights may be
              adjusted on the fly for slow starts for instance.

    (from http://haproxy.1wt.eu/download/1.4/doc/configuration.txt)

<p>
<em>Stickiness</em> is best when your backend servers are <b>not</b> identical,
and some users/clients should only ever go to some particular set of backend
servers.  Thus the user/client needs to be "sticky" to a given backend
server(s) -- that's when you need the sticky connect policies such as
<em>PerUser</em>, <em>PerHost</em>, and similar.

<p>
<b>SFTP/SCP Support</b><br>
The <code>mod_proxy</code> module only works for FTP/FTPS sessions; it does
<b>not</b> currently support/handle SFTP/SCP sessions.

<p>
<b>Logging</b><br>
The <code>mod_proxy</code> module supports different forms of logging.  The
main module logging is done via the
<a href="#ProxyLog"><code>ProxyLog</code></a> directive.  For debugging
purposes, the module also uses <a href="http://www.proftpd.org/docs/howto/Tracing.html">trace logging</a>, via the module-specific channels:
<ul>
  <li>proxy
  <li>proxy.conn
  <li>proxy.db
  <li>proxy.forward
  <li>proxy.ftp.conn
  <li>proxy.ftp.ctrl
  <li>proxy.ftp.data
  <li>proxy.ftp.msg
  <li>proxy.ftp.sess
  <li>proxy.ftp.xfer
  <li>proxy.reverse
  <li>proxy.session
  <li>proxy.uri
</ul>
Thus for trace logging, to aid in debugging, you would use the following in
your <code>proftpd.conf</code>:
<pre>
  TraceLog /path/to/proxy-trace.log
  Trace proxy:20
</pre>
This trace logging can generate large files; it is intended for debugging
use only, and should be removed from any production configuration.

<p>
<b>Suggested Future Features</b><br>
The following lists the features I hope to add to <code>mod_proxy</code>,
according to need, demand, inclination, and time:
<ul>
  <li>Sticky load balancing policies
  <li>FTPS connections to backend/destination servers
  <li>SFTP/SCP support
</ul>
See the GitHub <a href="https://github.com/Castaglia/proftpd-mod_proxy/issues">issues</a> page for current bugs and feature requests, and to report issues.

<p><a name="FAQ">
<b>Frequently Asked Questions</b><br>

<p>
<hr>
<h2><a name="Installation">Installation</a></h2>
To install <code>mod_proxy</code>, go to the third-party module area in
the proftpd source code and unpack the <code>mod_proxy</code> source tarball:
<pre>
  cd <i>proftpd-dir</i>/contrib/
  tar zxvf /path/to/mod_proxy-<i>version</i>.tar.gz
</pre>
after unpacking the latest proftpd-1.3.<i>x</i> source code.  For including
<code>mod_proxy</code> as a staticly linked module:
<pre>
  ./configure --with-modules=mod_proxy:...
</pre>
To build <code>mod_proxy</code> as a DSO module:
<pre>
  ./configure --enable-dso --with-shared=mod_proxy:...
</pre>
Then follow the usual steps:
<pre>
  make
  make install
</pre>

<p>
<hr>

<font size=2><b><i>
&copy; Copyright 2015 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr>
</body>
</html>
